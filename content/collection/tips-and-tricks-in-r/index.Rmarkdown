---
title: "Data Wrangling in R"
date: "`r format(Sys.time(), '%B %d, %Y')`"
author: 'Dina Arch'
subtitle: Completion of a final project for PSTAT 231 at UC Santa Barbara.
weight: 2
draft: false
images: 
series: 
tags:
- r markdown
- machine learning
- visualization
- classification
- principal components
categories:
- r project
editor_options:
  markdown:
    wrap: sentence
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
```

```{r}
library(stringr) # str_to_lower()
library(janitor) # clean_names()
library(palmerpenguins) # penguins
library(sjmisc) # move_columns
library(tidyverse)
```


# Data Wrangling Tips in R


Let's use a dataset called `penguins` in the `palmerpenguins` package (Reference: [Horst AM, Hill AP, & Gorman KB, 2020](https://allisonhorst.github.io/palmerpenguins/))

---

## Read in and view data

```{r}
data("penguins")
head(penguins_raw) # reads first 6 rows
names(penguins_raw) # lists variable names
summary(penguins_raw) # provides some descriptive statistics for each variable
```


How to read in data and make note of the missing values:
 
```{r, eval = FALSE}
data <- read_csv("data.csv", na = c("-999", "NA", "000")) #note: the `na` argument only works for "read_csv" and not "read_sav."
```

---

## Clean names

We see that the variable names are not "clean." As in, they have spaces and capital letters.
Usually, we want to use a format called "snake case", where we have lower case letters and spaces are replaced with underscores.
We can easily do this with the `clean_names()` function in the `janitor` package:

```{r}
penguins_new <- penguins_raw %>% 
  clean_names()

#Compare names
names(penguins_new)
names(penguins_raw)
```

---

## Move variable names

We can use the `move_columns()` function to rearrange our variable names. Lets say we want to move `clutch_completion` to the left of `body_mass_g`:

```{r}
penguins_move <- penguins_new %>% 
  move_columns(clutch_completion, .before = body_mass_g)

names(penguins_move)
```

---

## Recoding

### Examine class

Let's examine the `clutch_completion` variable.
(a character string denoting if the study nest observed with a full clutch, i.e., 2 eggs).
Let's see what the labels look like using `unique()`:

```{r}
unique(penguins_new$clutch_completion)
```

Right now, the levels are `Yes` and `No`.
Let's also check the variable type using `class()`:

```{r}
class(penguins_new$clutch_completion)
```

Let's make this a factor.

---

### Create factor

Since this variable is not a character (but a factor), we need to convert it.
We can do that using `factor()`:

```{r}
penguins_factor <- penguins_new %>% 
  mutate(clutch_factor = factor(clutch_completion))
```

Let's check the variable again:

```{r}
class(penguins_factor$clutch_factor)
unique(penguins_factor$clutch_factor)
```

---

### Recoding a factor

Let's say we want to recode our labels from `Yes` and `No` to `1` and `0`:

```{r}
penguins_recoded <- penguins_factor %>% 
  mutate(clutch_recoded = recode(clutch_factor,"Yes" = "1", "No" = "0"))
```

```{r}
class(penguins_recoded$clutch_recoded)
unique(penguins_recoded$clutch_recoded)
```

---

### Recoding a character into a factor

Let's look at another variable in the `penguins` dataset: `Sex` of the penguin:

```{r}
class(penguins_new$sex)
unique(penguins_new$sex)
```

Let's say we didn't do the process above, and it was still in `character` format.
We can combine those two steps by recoding character variables into factors (from `MALE` and `FEMALE` to `0` and `1`) using `recode_factor():`

```{r}
penguins_sex_recoded <- penguins_new %>% 
  mutate(sex_recoded = recode_factor(sex,"MALE" = "0", "FEMALE" = "1"))
```

Lets check the variable again:

```{r}
class(penguins_sex_recoded$sex_recoded)
unique(penguins_sex_recoded$sex_recoded)
```

*Side Note*.
I also wanted to make a quick note on what happens when you select the variable of interest first vs. not:

```{r}
penguins_recoded_select <- penguins_new %>% 
  select(sex) %>% 
  mutate(sex_recoded = recode_factor(sex,"MALE" = "0", "FEMALE" = "1"))

head(penguins_recoded_select)
head(penguins_sex_recoded)
```

---

### Recoding multiple variables

The dataset doesn't have any two variables that need to be recoded the same, but let's recode both `sex` and `clutch_completion` at the same time. *Not*e: this code should be used if you have two variables that need to have the same recoding, but it looks like this works too. 

```{r}
penguins_multiple <- penguins_new %>%  
    mutate_at(c("sex", "clutch_completion"),
              ~ recode_factor(., "MALE" = "0", "FEMALE" = "1",
                       "Yes" = "1", "No" = "0"))
penguins_multiple %>% 
  select(sex, clutch_completion) %>% 
  head()
```

---

## Creating reference variables

Recall slide 33 in the Multiple Regression lecture:

![](dummycoding.jpg)

Remember that when we enter a categorical variable into the model using `lm()`, R creates the reference variable for us, and picks the first category as the reference category.
For example, let's look at the `species` variable:

```{r}
class(penguins_new$species)
unique(penguins_new$species)
```

Let's clean this variable.
First, let's make the labels lowercase using `str_to_lower()`:

```{r}
penguin_species <- penguins_new %>% 
  mutate(species = str_to_lower(species))

unique(penguin_species$species)
```

Now, let's just keep the simple names of the penguins: `adelie`, `gentoo`, and `chinstrap` using the `separate()` function:

```{r}
penguins_species_clean <- penguin_species %>% 
  separate(species, into = c("species", "delete"), sep = " penguin") %>% 
  select(-delete)

unique(penguins_species_clean$species)
class(penguins_species_clean$species)
```

Let's also convert this new variable into a factor:

```{r}
penguins_species_clean$species <- factor(penguins_species_clean$species)

unique(penguins_species_clean$species)
class(penguins_species_clean$species)
```

Let's quickly run a simple linear regression using the `species` variable without creating the reference variables.
Let's predict `flipper_length_mm` from `species`:

```{r}
model_1 <- lm(flipper_length_mm ~ species, data = penguins_species_clean)
summary(model_1)
```

Here, it automatically created the reference variables and made `adelie` penguins the reference category.
What if we want to compare our results to `gentoo` penguins?
We can do that by converting the `chinstrap` and `adelie` into their own variables using `ifelse()`

```{r}
chinstrap <- ifelse(penguins_species_clean$species == 'chinstrap', 1, 0)
adelie <- ifelse(penguins_species_clean$species == 'adelie', 1, 0)
```

Then, we add them to our dataset using `cbind()`:

```{r}
penguins_reference <- penguins_species_clean %>% 
  cbind(chinstrap, adelie)

```

Let's look at the model again with `gentoo` as the reference variable.
Instead of `species`, we use `chinstrap` and `adelie`:

```{r}
model_2 <- lm(flipper_length_mm ~ chinstrap + adelie, data = penguins_reference)
summary(model_2)
```

Changing the reference category does NOT change our model.
It only allows us to make a more meaningful comparison.

---

## Collapsing variables 

### Continous to categorical

In lab 1, I go over how to collapse continuous variables into categorical. Let's categorize `body_mass_g` into `1`, `2`, `3`, and `4` levels. 

```{r}
summary(penguins_new$body_mass_g)

cont_cat <- penguins_new %>% 
  mutate(body_mass_factor = cut(body_mass_g,
                      breaks = c(2700, 3550, 4202, 4750, 6300),
                      labels = c("low", "medium_low", "medium_high", "high")))
```

---

### Categorical to categorical

Let's collapse our `body_mass_g` even further. This code is useful if you have a Likert-type scale with four categories, such as `Strong Agree` to `Strongly Disagree` and want to collapse to a category with those who responded `Strongly Agree` and `Agree` as `1`, and `Disagree` and `Strongly Disagree` as `2`. We can use `fct_collapse` to collapse factor levels into groups.

```{r}
cat_cat <- cont_cat %>% 
  mutate(body_mass_collpase = 
           fct_collapse(body_mass_factor,
                        low = c("low", "medium_low"),
                        high = c("medium_high", "high")))
```

---
